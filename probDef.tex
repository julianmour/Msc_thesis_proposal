%! Author = julianmour
%! Date = 01/05/2023


\section{Problem Definition}
In this section, we define the problem we address.
For simplicity's sake, all our definitions and algorithms focus on images with two objects -- the target one and the perturbed one -- but they can extend to multiple objects.
%In general, we can discuss the problem with several target and non-target objects, but for simplicity we will focus on one object from each type.
Informally, given a multi-label classifier, an image showing a target object, we aim to compute a robust layer-neighborhood, given for a target object (target class).
The neighborhood is defined by a sequence of epsilons representing the perturbation per layer.
%Each layer is defined to be a set of pixels that share the same distance from a specific non-target object (non-target class) in the image.
We begin with definitions and then define our problem.
A multi-classifier is a function mapping an instance (in our case an image) to a subset of labels from a set of classes $C$ -
%\Dana{complete}
$F:[0, 1]^{n \times m} \rightarrow P(C)$\\
%\Dana{complete}.
Given an image, the classification of $F$ is $F(x)$ = \{$c_{target}$, $c_{non-target}$\}.
%\Dana{complete}.
A neighborhood of input $x$ is a set of inputs containing $x$.
A neighborhood $I$ is robust if all inputs in it are classified to the target label: $\forall x' \in I: c_{target} \in F(x').$\\
%\Dana{complette with words and with mathematical notation}.
We focus on layered neighborhoods.
To define it, we denote the set of pixels showing an object in an image by $P_{object}$.
Given an image showing two objects, the target one with class $c_{target}$ and the perturbed one with class $c_{non-target}$ and its set of pixels $P_{non-target}$, the $d^\text{th}$ layer is defined to be the set of pixels that are distant from $P_{non-target}$ by $d$ pixels, where we define the distance between a pixel $p_0 = (i_0, j_0)$ and a set of pixels $P$ to be the smallest distance from $p_0$ to a pixel $p_k = (i_k, j_k)$ in $P$:
\begin{gather*}
    dist((i_0,j_0), P) = \min_{(i_k, j_k) \in P}\{dist((i_0, j_0), (i_k, j_k))\}\\
    l_d^x = \{(i,j) \in [1,n]\times [1,m] \mid dist((i, j), P_{non-target}) = d\}\\
\end{gather*}
%Formally, we define the set of layers $L_x$:
%\begin{gather*}
%    L_x = \{l_0^x, l_1^x, \ldots, l_r^x\}\\
%    \textrm{s.t.}  l_d^x = \{(i,j) \in [1,n]\times [1,m] \mid dist((i, j),$ non-target object$) = d\}
%\end{gather*}
We denote the set of layers by $L_x = \{l_0^x, l_1^x, \ldots, l_r^x\}$.
A \textbf{layered neighborhood} $I$ of an image $x$ is defined by giving a maximal allowed perturbation $\varepsilon_d^x$ for the $d^\text{th}$ layer, where $x'$ is in $I$ if and only if each pixel's value in $x'$ differs from its value in $x$ by at most $\varepsilon_d^x$:\\
%\Dana{complete in words and mathematically}.
\begin{gather*}
    \varepsilon_x = (\varepsilon_0^x, \varepsilon_1^x, \ldots, \varepsilon_r^x)\\
    I = \{x' \mid \forall l_d^x\in L_x: \forall (i,j)\in l_d^x: x'_{i,j} \in [x_{i,j}-\varepsilon_d^x, x_{i,j}+\varepsilon_d^x]\}\\
\end{gather*}
We also denote the set of all robust layered neighborhoods of an image $x$ with $RLN_x$, and the set of epsilon sequences representing them with $RLN_x^\varepsilon$.\\
In addition, we assume a weight vector, assigning a weight for each layer:
\begin{gather*}
    w_x = (w_0^x, w_1^x, \ldots, w_r^x)\\
\end{gather*}
Now we can define our problem.
Given a classifier $F:[0, 1]^{n \times m} \rightarrow P(C)$, an image $x$ of size $n\times m$ containing two objects: $c_{target}$ and $c_{non-target}$ \textrm{s.t.} $F(x)$ = \{$c_{target}$, $c_{non-target}$\},
%\Dana{probably merge with the above}
%we define the set of layers to be:
%\begin{gather*}
%    L_x = \{l_0^x, l_1^x, \ldots, l_r^x\}\\
%    \textrm{s.t.}  l_d^x = \{(i,j) \in [1,n]\times [1,m] \mid dist((i, j), c_{non-target}) = d\}
%\end{gather*}
%In addition, we assume a weight vector, assigning a weight for each layer:
%\begin{gather*}
%    w_x = (w_0^x, w_1^x, \ldots, w_r^x)\\
%\end{gather*}
%\Dana{probably merge with the above}
We aim to compute a sequence of epsilons $\varepsilon_x^* = ({\varepsilon_0^x}^*, {\varepsilon_1^x}^*, \ldots, {\varepsilon_r^x}^*)$ that defines a \textbf{maximal robust layered neighborhood} $I_x^*$:
\begin{gather*}
    \varepsilon_x^*  = argmax_{\varepsilon_x \in RLN_x^\varepsilon} \{w_x \times \varepsilon_x^T\}\\
%    I_x = \{x' \mid \forall l_d^x\in L_x: \forall (i,j)\in l_d^x: x'_{i,j} \in [x_{i,j}-\varepsilon_d^x, x_{i,j}+\varepsilon_d^x]\}\\
\end{gather*}
%\Dana{comment 1: don't put \$ in gather env}
%\Dana{comment 2: we don't build programs, but rather algorithms}
%\Dana{comment 3: in this section, we aim to compute maximal neighborhoods, not design an algorithm, this will come in the nxt section}